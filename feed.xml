<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://jsylvester.com/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jsylvester.com/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-10-23T16:04:55+00:00</updated><id>https://jsylvester.com/feed.xml</id><title type="html">blank</title><subtitle>Researcher in Artificial Intelligence and Cybersecurity, focusing on autonomous network defence, novelty detection, and reinforcement learning. </subtitle><entry><title type="html">Hack The Box - Weak RSA</title><link href="https://jsylvester.com/blog/2025/htb-weak-rsa/" rel="alternate" type="text/html" title="Hack The Box - Weak RSA"/><published>2025-10-15T12:00:00+00:00</published><updated>2025-10-15T12:00:00+00:00</updated><id>https://jsylvester.com/blog/2025/htb-weak-rsa</id><content type="html" xml:base="https://jsylvester.com/blog/2025/htb-weak-rsa/"><![CDATA[<ul> <li>CTF: Hack The Box</li> <li>Challenge Name: Weak RSA</li> <li>Category: Cryptography</li> <li>Difficulty: Easy</li> </ul> <h2 id="synopsis">Synopsis</h2> <p>In this CTF challenge, we are given an RSA public key and an encrypted flag file. The goal is to decrypt the flag using Wiener’s attack, which targets RSA keys with small private exponents. By exploiting this vulnerability, we can recover the private key and decrypt the encrypted message.</p> <h2 id="description">Description</h2> <p>Can you decrypt the message and get the flag?</p> <h2 id="challenge">Challenge</h2> <p>The challenge contains two files:</p> <ul> <li><code class="language-plaintext highlighter-rouge">key.pub</code>: This file contains the public key used to encrypt the flag</li> <li><code class="language-plaintext highlighter-rouge">flag.enc</code> This file contains the encrypted flag</li> </ul> <p>The public key looks like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-----BEGIN PUBLIC KEY-----
MIIBHzANBgkqhkiG9w0BAQEFAAOCAQwAMIIBBwKBgQMwO3kPsUnaNAbUlaubn7ip
4pNEXjvUOxjvLwUhtybr6Ng4undLtSQPCPf7ygoUKh1KYeqXMpTmhKjRos3xioTy
23CZuOl3WIsLiRKSVYyqBc9d8rxjNMXuUIOiNO38ealcR4p44zfHI66INPuKmTG3
RQP/6p5hv1PYcWmErEeDewKBgGEXxgRIsTlFGrW2C2JXoSvakMCWD60eAH0W2PpD
qlqqOFD8JA5UFK0roQkOjhLWSVu8c6DLpWJQQlXHPqP702qIg/gx2o0bm4EzrCEJ
4gYo6Ax+U7q6TOWhQpiBHnC0ojE8kUoqMhfALpUaruTJ6zmj8IA1e1M6bMqVF8sr
lb/N
-----END PUBLIC KEY-----
</code></pre></div></div> <p>The hexdump of the encrypted flag looks like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00000000  01 a2 5f ef 76 63 5b db  ea 7e e7 6b 5a c4 31 8a  |.._.vc[..~.kZ.1.|
00000010  07 c4 a8 d1 34 ce 49 a5  39 56 17 d1 d6 bf c6 5e  |....4.I.9V.....^|
00000020  15 47 f2 c2 15 e4 28 85  2b 33 4c 75 22 da 54 e9  |.G....(.+3Lu".T.|
00000030  02 08 24 be a0 c9 46 30  eb 56 50 a7 01 d6 be 6a  |..$...F0.VP....j|
00000040  40 ec b8 02 e1 f4 c0 c9  7c 6a 1a cf e4 99 d8 e7  |@.......|j......|
00000050  e5 85 7b c2 be ec 7f 2c  95 86 f0 f4 fc 59 45 a9  |..{....,.....YE.|
00000060  a9 8d 13 ef ef ac 58 38  08 78 e6 fc 2c ad ef 63  |......X8.x..,..c|
00000070  8f 4e 26 16 48 6c 32 b9  d3 8d c6 e5 5b 6f a4 1d  |.N&amp;.Hl2.....[o..|
00000080  ee                                                |.|
00000081

</code></pre></div></div> <h2 id="solution">Solution</h2> <h3 id="problem-setup">Problem Setup</h3> <p>In this challenge, we are given an RSA public key (<code class="language-plaintext highlighter-rouge">key.pub</code>) with a modulus <code class="language-plaintext highlighter-rouge">n</code> and public exponent <code class="language-plaintext highlighter-rouge">e</code>, as well as an encrypted flag file (<code class="language-plaintext highlighter-rouge">flag.enc</code>). Our goal is to decrypt the flag using information derived from the public key.</p> <h3 id="step-1-extract-the-rsa-parameters">Step 1: Extract the RSA Parameters</h3> <p>First, we extract the modulus <code class="language-plaintext highlighter-rouge">n</code> and the public exponent <code class="language-plaintext highlighter-rouge">e</code> from the RSA public key file using <code class="language-plaintext highlighter-rouge">openssl</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Extract modulus and exponent</span>
openssl rsa <span class="nt">-pubin</span> <span class="nt">-in</span> key.pub <span class="nt">-text</span>

</code></pre></div></div> <p>The output is:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Public-Key: (1026 bit)
Modulus:
    03:30:3b:79:0f:b1:49:da:34:06:d4:95:ab:9b:9f:
    b8:a9:e2:93:44:5e:3b:d4:3b:18:ef:2f:05:21:b7:
    26:eb:e8:d8:38:ba:77:4b:b5:24:0f:08:f7:fb:ca:
    0a:14:2a:1d:4a:61:ea:97:32:94:e6:84:a8:d1:a2:
    cd:f1:8a:84:f2:db:70:99:b8:e9:77:58:8b:0b:89:
    12:92:55:8c:aa:05:cf:5d:f2:bc:63:34:c5:ee:50:
    83:a2:34:ed:fc:79:a9:5c:47:8a:78:e3:37:c7:23:
    ae:88:34:fb:8a:99:31:b7:45:03:ff:ea:9e:61:bf:
    53:d8:71:69:84:ac:47:83:7b
Exponent:
    61:17:c6:04:48:b1:39:45:1a:b5:b6:0b:62:57:a1:
    2b:da:90:c0:96:0f:ad:1e:00:7d:16:d8:fa:43:aa:
    5a:aa:38:50:fc:24:0e:54:14:ad:2b:a1:09:0e:8e:
    12:d6:49:5b:bc:73:a0:cb:a5:62:50:42:55:c7:3e:
    a3:fb:d3:6a:88:83:f8:31:da:8d:1b:9b:81:33:ac:
    21:09:e2:06:28:e8:0c:7e:53:ba:ba:4c:e5:a1:42:
    98:81:1e:70:b4:a2:31:3c:91:4a:2a:32:17:c0:2e:
    95:1a:ae:e4:c9:eb:39:a3:f0:80:35:7b:53:3a:6c:
    ca:95:17:cb:2b:95:bf:cd

</code></pre></div></div> <h3 id="step-2-analyse-the-parameters">Step 2: Analyse the Parameters</h3> <p>Generally in RSA implementations the encryption exponent is set to a smaller value like 65537. Given that this encryption exponent is large it could indicate a non standard implementation and the decryption exponent could be small.</p> <p>Wiener’s attack specifically exploits RSA setups where the private exponent <code class="language-plaintext highlighter-rouge">d</code> is small relative to <code class="language-plaintext highlighter-rouge">n</code>. The attack is effective when:</p> <pre><code class="language-math">d &lt; \frac{1}{3} n^{\frac{1}{4}}
</code></pre> <h3 id="step-3-apply-wieners-attack">Step 3: Apply Wiener’s Attack</h3> <p>Wiener’s attack can be used to recover the private key <code class="language-plaintext highlighter-rouge">d</code> when the RSA public key has a small private exponent <code class="language-plaintext highlighter-rouge">d</code>. The <code class="language-plaintext highlighter-rouge">owiener</code> Python library implements Wiener’s attack, which we can use to find <code class="language-plaintext highlighter-rouge">d</code>.</p> <p>Here’s the code used for applying Wiener’s attack:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">owiener</span>

<span class="c1"># Given RSA parameters
</span><span class="n">n</span> <span class="o">=</span> <span class="mh">0x03303B790FB149DA3406D495AB9B9FB8A9E293445E3BD43B18EF2F0521B726EBE8D838BA774BB5240F08F7FBCA0A142A1D4A61EA973294E684A8D1A2CDF18A84F2DB7099B8E977588B0B891292558CAA05CF5DF2BC6334C5EE5083A234EDFC79A95C478A78E337C723AE8834FB8A9931B74503FFEA9E61BF53D8716984AC47837B</span>
<span class="n">e</span> <span class="o">=</span> <span class="mh">0x6117C60448B139451AB5B60B6257A12BDA90C0960FAD1E007D16D8FA43AA5AAA3850FC240E5414AD2BA1090E8E12D6495BBC73A0CBA562504255C73EA3FBD36A8883F831DA8D1B9B8133AC2109E20628E80C7E53BABA4CE5A14298811E70B4A2313C914A2A3217C02E951AAEE4C9EB39A3F080357B533A6CCA9517CB2B95BFCD</span>

<span class="c1"># Attempt Wiener's attack
</span><span class="n">d</span> <span class="o">=</span> <span class="n">owiener</span><span class="p">.</span><span class="nf">attack</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Failed</span><span class="sh">"</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Hacked d={}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
</code></pre></div></div> <p>The script attempts to recover the private exponent <code class="language-plaintext highlighter-rouge">d</code> using the <code class="language-plaintext highlighter-rouge">owiener.attack</code> function. If successful, we obtain the private key.</p> <h3 id="step-3-decrypt-the-flag">Step 3: Decrypt the Flag</h3> <p>Once the private key <code class="language-plaintext highlighter-rouge">d</code> is obtained, we proceed to decrypt the flag. The flag is stored in the file <code class="language-plaintext highlighter-rouge">flag.enc</code>, and we first read its content as bytes. Then, we convert it to an integer <code class="language-plaintext highlighter-rouge">c</code> and decrypt it using the formula <code class="language-plaintext highlighter-rouge">m = c^d mod n</code>, where <code class="language-plaintext highlighter-rouge">m</code> is the plaintext message.</p> <p>Here’s the code for decryption:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Read the encrypted flag
</span><span class="n">in_file</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">flag.enc</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rb</span><span class="sh">"</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">in_file</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span>
<span class="n">in_file</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>

<span class="c1"># Convert the encrypted data to an integer
</span><span class="n">c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">.</span><span class="nf">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="sh">'</span><span class="s">big</span><span class="sh">'</span><span class="p">)</span>

<span class="c1"># Decrypt the message using the private key
</span><span class="n">decrypted_message</span> <span class="o">=</span> <span class="nf">pow</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">).</span><span class="nf">to_bytes</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="sh">'</span><span class="s">big</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">decrypted_message</span><span class="p">)</span>
</code></pre></div></div> <p>After decryption, the output is the plaintext flag. This process successfully recovers the original message using Wiener’s attack, demonstrating the vulnerability of RSA with small private exponents.</p> <h3 id="summary">Summary</h3> <p>In this challenge, we exploited a vulnerability in RSA encryption using Wiener’s attack to recover the private key and decrypt the flag. This highlights the importance of selecting a sufficiently large private exponent to prevent such attacks in RSA implementations.</p> <h3 id="output">Output</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Private key d found: 44217944188473654528518593968293401521897205851340809945591908757815783834933
b'\x01\xa2_\xefvc[\xdb\xea~\xe7kZ\xc41\x8a\x07\xc4\xa8\xd14\xceI\xa59V\x17\xd1\xd6\xbf\xc6^\x15G\xf2\xc2\x15\xe4(\x85+3Lu"\xdaT\xe9\x02\x08$\xbe\xa0\xc9F0\xebVP\xa7\x01\xd6\xbej@\xec\xb8\x02\xe1\xf4\xc0\xc9|j\x1a\xcf\xe4\x99\xd8\xe7\xe5\x85{\xc2\xbe\xec\x7f,\x95\x86\xf0\xf4\xfcYE\xa9\xa9\x8d\x13\xef\xef\xacX8\x08x\xe6\xfc,\xad\xefc\x8fN&amp;\x16Hl2\xb9\xd3\x8d\xc6\xe5[o\xa4\x1d\xee'
b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02!\xcf\xb2\x98\x83\xb0o@\x9ag\x9aX\xa4\xe9{Dn(\xb2D\xbb\xcd\x06\x87\xd1x\xa8\xab\x87"\xbf\x86\xda\x06\xa6.\x04,\x89-)!\xb36W\x1e\x9f\xf7\xac\x9d\x89\xba\x90Q+\xacL\xfb\x8d~J9\x01\xbb\xcc\xf5\xdf\xac\x01\xb2{\xdd\xd3_\x1c\xa5SD\xa7YC\xdf\x9a\x18\xea\xdb4L\xf7\xcfU\xfa\x0b\xaap\x05\xbf\xe3/A\x00HTB{s1mpl3_Wi3n3rs_4tt4ck}'

</code></pre></div></div> <h2 id="solution-code">Solution Code</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">owiener</span>

<span class="n">n</span> <span class="o">=</span> <span class="mh">0x03303B790FB149DA3406D495AB9B9FB8A9E293445E3BD43B18EF2F0521B726EBE8D838BA774BB5240F08F7FBCA0A142A1D4A61EA973294E684A8D1A2CDF18A84F2DB7099B8E977588B0B891292558CAA05CF5DF2BC6334C5EE5083A234EDFC79A95C478A78E337C723AE8834FB8A9931B74503FFEA9E61BF53D8716984AC47837B</span>
<span class="n">e</span> <span class="o">=</span> <span class="mh">0x6117C60448B139451AB5B60B6257A12BDA90C0960FAD1E007D16D8FA43AA5AAA3850FC240E5414AD2BA1090E8E12D6495BBC73A0CBA562504255C73EA3FBD36A8883F831DA8D1B9B8133AC2109E20628E80C7E53BABA4CE5A14298811E70B4A2313C914A2A3217C02E951AAEE4C9EB39A3F080357B533A6CCA9517CB2B95BFCD</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">owiener</span><span class="p">.</span><span class="nf">attack</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Failed</span><span class="sh">"</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Hacked d={}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
    
    
<span class="n">in_file</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">flag.enc</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rb</span><span class="sh">"</span><span class="p">)</span> 
<span class="n">data</span> <span class="o">=</span> <span class="n">in_file</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span> 
<span class="n">in_file</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># Convert the encrypted data to an integer
</span><span class="n">c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">.</span><span class="nf">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="sh">'</span><span class="s">big</span><span class="sh">'</span><span class="p">)</span>

<span class="c1"># Decrypt the message using the private key
</span><span class="n">decrypted_message</span> <span class="o">=</span> <span class="nf">pow</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">).</span><span class="nf">to_bytes</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="sh">'</span><span class="s">big</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">decrypted_message</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="write-ups"/><category term="cryptography"/><summary type="html"><![CDATA[Write up from Hack The Box]]></summary></entry><entry><title type="html">TCP1P 2024 - Skibidi Format</title><link href="https://jsylvester.com/blog/2025/tcp1p-2024-skibidi-format/" rel="alternate" type="text/html" title="TCP1P 2024 - Skibidi Format"/><published>2025-09-13T12:00:00+00:00</published><updated>2025-09-13T12:00:00+00:00</updated><id>https://jsylvester.com/blog/2025/tcp1p-2024-skibidi-format</id><content type="html" xml:base="https://jsylvester.com/blog/2025/tcp1p-2024-skibidi-format/"><![CDATA[<ul> <li>CTF: TCP1P 2024</li> <li>Challenge Name: Skibidi Format</li> <li>Category: Forensics</li> <li>Difficulty: Unknown</li> </ul> <h2 id="synopsis">Synopsis</h2> <p>The solution involves reading a <code class="language-plaintext highlighter-rouge">.skibidi</code> file, extracting the header metadata, decrypting the compressed pixel data using AES-256-GCM, and decompressing it with Zstandard. The pixel data is then reconstructed into an image using the <code class="language-plaintext highlighter-rouge">PIL</code> library, based on the specified number of colour channels.</p> <h2 id="description">Description</h2> <p>So my friend just made a new image format and asked me to give him a test file, so I gave him my favorite png of all time. But the only thing I receive back is just my image with his new format and its “specification” file, don’t know what that is. Can you help me read this file?</p> <h2 id="challenge">Challenge</h2> <p>The challenge contains two files:</p> <ul> <li><code class="language-plaintext highlighter-rouge">spec.html</code>: This is a file describing the detail of the new photo format</li> <li><code class="language-plaintext highlighter-rouge">suisei.skibidi</code> This is the picture in the format specified by the <code class="language-plaintext highlighter-rouge">spec.html</code> file</li> </ul> <h3 id="file-format-specification">File Format Specification</h3> <p>Based on the <code class="language-plaintext highlighter-rouge">spec.html</code> a <code class="language-plaintext highlighter-rouge">.skibidi</code> file consists of two main sections:</p> <ol> <li><strong>Header</strong>: Contains metadata about the image, such as dimensions, colour channels, compression method, and encryption details.</li> <li><strong>Data Section</strong>: Holds the encrypted and compressed pixel data. <h4 id="header-structure">Header Structure</h4> </li> </ol> <p>The header has a fixed size of 58 bytes and includes the following fields:</p> <p>| Offset | Field | Size (bytes) | Description | <br/> | —— | ———— | ———— | ————————————— | | 0 | Magic Number | 4 | Identifier (“SKB1”) for the file format | <br/> | 4 | Width | 4 | Image width in pixels | <br/> | 8 | Height | 4 | Image height in pixels | <br/> | 12 | Color Channels | 1 | Number of color channels (1 = Grayscale, 3 = RGB, 4 = RGBA) | | 13 | Compression ID | 1 | Compression algorithm identifier (1 = Zstandard) | <br/> | 14 | AES Key | 32 | AES-256 encryption key | <br/> | 46 | AES Initialization Vector (IV) | 12 | AES-GCM IV | |</p> <h4 id="data-section">Data Section</h4> <p>The pixel data is encrypted and compressed, following these steps:</p> <ol> <li><strong>Compression</strong>: Pixel data is compressed using the specified compression algorithm (currently, Zstandard).</li> <li><strong>Encryption</strong>: Compressed data is encrypted using AES-256-GCM with the provided key and IV.</li> </ol> <h2 id="solution">Solution</h2> <p>To solve this problem, we need to:</p> <ol> <li>Read the <code class="language-plaintext highlighter-rouge">.skibidi</code> file, extracting header information.</li> <li>Decrypt the encrypted data using the AES key and IV.</li> <li>Decompress the decrypted data using the specified compression method.</li> <li>Reconstruct the image using the decompressed pixel data.</li> </ol> <h3 id="step-1-importing-required-libraries">Step 1. Importing Required Libraries</h3> <p>The necessary libraries are imported, including <code class="language-plaintext highlighter-rouge">struct</code> for reading binary data, <code class="language-plaintext highlighter-rouge">Cryptodome.Cipher</code> for AES decryption, <code class="language-plaintext highlighter-rouge">zstandard</code> for decompression, and <code class="language-plaintext highlighter-rouge">PIL</code> and <code class="language-plaintext highlighter-rouge">numpy</code> for image manipulation.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">struct</span>
<span class="kn">from</span> <span class="n">Cryptodome.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>
<span class="kn">import</span> <span class="n">zstandard</span> <span class="k">as</span> <span class="n">zstd</span>
<span class="kn">from</span> <span class="n">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
</code></pre></div></div> <h3 id="step-2-reading-the-skibidi-file">Step 2. Reading the <code class="language-plaintext highlighter-rouge">.skibidi</code> File</h3> <p>The <code class="language-plaintext highlighter-rouge">read_skibidi_file</code> function takes the file path of a <code class="language-plaintext highlighter-rouge">.skibidi</code> file, opens it in binary mode, and reads the header to extract metadata such as image dimensions, colour channels, compression method, and encryption details.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">read_skibidi_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="sh">'</span><span class="s">rb</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># Read header
</span>        <span class="n">magic</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">magic</span> <span class="o">!=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">SKB1</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">Invalid file format</span><span class="sh">"</span><span class="p">)</span>
        
        <span class="n">width</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">'</span><span class="s">&lt;I</span><span class="sh">'</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">'</span><span class="s">&lt;I</span><span class="sh">'</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">compression_id</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">aes_key</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
        <span class="n">aes_iv</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
        
        <span class="c1"># Read encrypted data
</span>        <span class="n">encrypted_data</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span>
        <span class="bp">...</span>

</code></pre></div></div> <p>When running this code and printing out the values for width, height, channels and compression_id you get the following output :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Width 3840 - height 2160 - channels  4 - compression 1
</code></pre></div></div> <p>These values will be useful in the future when it comes to converting the data into an image, the compression method is also using Zstandard which is the only method supported based on the specification.</p> <h3 id="step-3-decrypting-the-pixel-data">Step 3. Decrypting the Pixel Data</h3> <p>Using the AES-256-GCM algorithm, the encrypted pixel data is decrypted with the extracted key and IV from the header. This step ensures data confidentiality and integrity.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="bp">...</span>
        <span class="c1"># Decrypt the data
</span>        <span class="n">cipher</span> <span class="o">=</span> <span class="n">AES</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">aes_key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_GCM</span><span class="p">,</span> <span class="n">nonce</span><span class="o">=</span><span class="n">aes_iv</span><span class="p">)</span>
        <span class="n">decrypted_data</span> <span class="o">=</span> <span class="n">cipher</span><span class="p">.</span><span class="nf">decrypt</span><span class="p">(</span><span class="n">encrypted_data</span><span class="p">)</span>
        <span class="bp">...</span>

</code></pre></div></div> <h3 id="step-4-decompressing-the-data">Step 4. Decompressing the Data</h3> <p>The decompressed pixel data is obtained using the Zstandard library, based on the specified compression method in the header. Error handling ensures that decompression issues are reported.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="bp">...</span>
        <span class="c1"># Decompress the data
</span>        <span class="k">try</span><span class="p">:</span>
            <span class="n">dctx</span> <span class="o">=</span> <span class="n">zstd</span><span class="p">.</span><span class="nc">ZstdDecompressor</span><span class="p">()</span>
            <span class="n">pixel_data</span> <span class="o">=</span> <span class="n">dctx</span><span class="p">.</span><span class="nf">decompress</span><span class="p">(</span><span class="n">decrypted_data</span><span class="p">,</span> <span class="n">max_output_size</span><span class="o">=</span><span class="mi">100000000</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">zstd</span><span class="p">.</span><span class="n">ZstdError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Decompression failed:</span><span class="sh">"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">An error occurred:</span><span class="sh">"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        
        <span class="c1"># Return the extracted data
</span>        <span class="k">return</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">compression_id</span><span class="p">,</span> <span class="n">pixel_data</span>
</code></pre></div></div> <h3 id="step-5-reconstructing-the-image">Step 5. Reconstructing the Image</h3> <p>The image is reconstructed from the decompressed pixel data. Since the number of channels is 4, the pixel data is reshaped accordingly. The <code class="language-plaintext highlighter-rouge">PIL</code> library is used to convert the array into an image and save or display it.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">compression</span><span class="p">,</span> <span class="n">pixel_data</span> <span class="o">=</span> <span class="nf">read_skibidi_file</span><span class="p">(</span><span class="sh">"</span><span class="s">./suisei.skibidi</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Width </span><span class="si">{</span><span class="n">width</span><span class="si">}</span><span class="s"> - height </span><span class="si">{</span><span class="n">height</span><span class="si">}</span><span class="s"> - channels  </span><span class="si">{</span><span class="n">channels</span><span class="si">}</span><span class="s"> - compression </span><span class="si">{</span><span class="n">compression</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="n">width</span> <span class="o">=</span> <span class="mi">3840</span>  
<span class="n">height</span> <span class="o">=</span> <span class="mi">2160</span>  
<span class="n">rgba_data</span> <span class="o">=</span> <span class="n">pixel_data</span> 

<span class="c1"># Convert byte array to a NumPy array
</span><span class="n">image_array</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">frombuffer</span><span class="p">(</span><span class="n">rgba_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint8</span><span class="p">).</span><span class="nf">reshape</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="c1"># Create an image from the array
</span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nf">fromarray</span><span class="p">(</span><span class="n">image_array</span><span class="p">,</span> <span class="sh">'</span><span class="s">RGBA</span><span class="sh">'</span><span class="p">)</span>

<span class="c1"># Save or display the image
</span><span class="n">image</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="sh">'</span><span class="s">output_image.png</span><span class="sh">'</span><span class="p">)</span>
<span class="n">image</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div> <h3 id="summary">Summary</h3> <p>The solution shows how to read the <code class="language-plaintext highlighter-rouge">.skibidi</code> file format by:</p> <ol> <li>Extracting metadata from the header.</li> <li>Decrypting and decompressing the pixel data.</li> <li>Reconstructing the image using <code class="language-plaintext highlighter-rouge">PIL</code> based on the colour channels.</li> </ol> <h3 id="output">Output</h3> <p>The output for this code is an image where the photo contains the flag.</p> <p align="center"> <img src="/assets/img/posts/tcp1p-2024-skibidi-format/output_image.png" alt="Output Image" style="max-width: 100%; height: auto; border-radius: 10px;"/> </p> <h2 id="solution-code">Solution Code</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">struct</span>
<span class="kn">from</span> <span class="n">Cryptodome.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>
<span class="kn">import</span> <span class="n">zstandard</span> <span class="k">as</span> <span class="n">zstd</span>
<span class="kn">from</span> <span class="n">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">read_skibidi_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="sh">'</span><span class="s">rb</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># Read header
</span>        <span class="n">magic</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">magic</span> <span class="o">!=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">SKB1</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">Invalid file format</span><span class="sh">"</span><span class="p">)</span>
        
        <span class="n">width</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">'</span><span class="s">&lt;I</span><span class="sh">'</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">'</span><span class="s">&lt;I</span><span class="sh">'</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">compression_id</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">aes_key</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
        <span class="n">aes_iv</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
        
        <span class="c1"># Read encrypted data
</span>        <span class="n">encrypted_data</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span>

        <span class="c1"># Decrypt the data
</span>        <span class="n">cipher</span> <span class="o">=</span> <span class="n">AES</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">aes_key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_GCM</span><span class="p">,</span> <span class="n">nonce</span><span class="o">=</span><span class="n">aes_iv</span><span class="p">)</span>
        <span class="n">decrypted_data</span> <span class="o">=</span> <span class="n">cipher</span><span class="p">.</span><span class="nf">decrypt</span><span class="p">(</span><span class="n">encrypted_data</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">decrypted_data</span><span class="p">))</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">decrypted_data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
        <span class="c1"># Decompress the data
</span>        <span class="k">try</span><span class="p">:</span>
            <span class="n">dctx</span> <span class="o">=</span> <span class="n">zstd</span><span class="p">.</span><span class="nc">ZstdDecompressor</span><span class="p">()</span>
            <span class="n">pixel_data</span> <span class="o">=</span> <span class="n">dctx</span><span class="p">.</span><span class="nf">decompress</span><span class="p">(</span><span class="n">decrypted_data</span><span class="p">,</span> <span class="n">max_output_size</span><span class="o">=</span><span class="mi">100000000</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">zstd</span><span class="p">.</span><span class="n">ZstdError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Decompression failed:</span><span class="sh">"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">An error occurred:</span><span class="sh">"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        
        <span class="c1"># Interpret pixel data based on channels
</span>        <span class="k">return</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">compression_id</span><span class="p">,</span> <span class="n">pixel_data</span>

<span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">compression</span><span class="p">,</span> <span class="n">pixel_data</span> <span class="o">=</span> <span class="nf">read_skibidi_file</span><span class="p">(</span><span class="sh">"</span><span class="s">./suisei.skibidi</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Width </span><span class="si">{</span><span class="n">width</span><span class="si">}</span><span class="s"> - height </span><span class="si">{</span><span class="n">height</span><span class="si">}</span><span class="s"> - channels  </span><span class="si">{</span><span class="n">channels</span><span class="si">}</span><span class="s"> - compression </span><span class="si">{</span><span class="n">compression</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="n">width</span> <span class="o">=</span> <span class="mi">3840</span>  
<span class="n">height</span> <span class="o">=</span> <span class="mi">2160</span>  
<span class="n">rgba_data</span> <span class="o">=</span> <span class="n">pixel_data</span> 

<span class="c1"># Convert byte array to a NumPy array
</span><span class="n">image_array</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">frombuffer</span><span class="p">(</span><span class="n">rgba_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint8</span><span class="p">).</span><span class="nf">reshape</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="c1"># Create an image from the array
</span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nf">fromarray</span><span class="p">(</span><span class="n">image_array</span><span class="p">,</span> <span class="sh">'</span><span class="s">RGBA</span><span class="sh">'</span><span class="p">)</span>

<span class="c1"># Save or display the image
</span><span class="n">image</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="sh">'</span><span class="s">output_image.png</span><span class="sh">'</span><span class="p">)</span>
<span class="n">image</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="write-ups"/><category term="forensics"/><summary type="html"><![CDATA[Write up from the TCP1P 2024 CTF competition]]></summary></entry><entry><title type="html">TCP1P 2024 - Imperfect Guesser</title><link href="https://jsylvester.com/blog/2025/tcp1p-2024-imperfect-guesser/" rel="alternate" type="text/html" title="TCP1P 2024 - Imperfect Guesser"/><published>2025-08-15T12:00:00+00:00</published><updated>2025-08-15T12:00:00+00:00</updated><id>https://jsylvester.com/blog/2025/tcp1p-2024-imperfect-guesser</id><content type="html" xml:base="https://jsylvester.com/blog/2025/tcp1p-2024-imperfect-guesser/"><![CDATA[<ul> <li>CTF: TCP1P 2024</li> <li>Challenge Name: Imperfect Guesser</li> <li>Category: Reverse</li> <li>Difficulty: Unknown</li> </ul> <h2 id="synopsis">Synopsis</h2> <p>Use gradient descent to reverse-engineer a PyTorch model, aiming to recover the input from a given output to retrieve a hidden flag</p> <h2 id="description">Description</h2> <p>Leaving a floating secret crumbs with the help of untrained labour, now “guess” the flag.</p> <h2 id="challenge">Challenge</h2> <p>The challenge contains one file:</p> <ul> <li><code class="language-plaintext highlighter-rouge">chally.py</code>: This is the main file that hides the flag by passing it through a PyTorch model</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">torch</span><span class="p">,</span> <span class="n">random</span>
<span class="kn">import</span> <span class="n">torch.nn</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">flag</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TCP1P{REDACTED}</span><span class="sh">"</span>

<span class="k">def</span> <span class="nf">floatify</span><span class="p">(</span><span class="n">ip</span><span class="p">):</span>
	<span class="n">flag</span> <span class="o">=</span> <span class="p">[</span><span class="nf">float</span><span class="p">(</span><span class="nf">ord</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">]</span>
	<span class="n">normalized</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="n">flag</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">normalized</span>

<span class="k">def</span> <span class="nf">tf</span><span class="p">(</span><span class="n">_in</span><span class="p">,</span><span class="n">_out</span><span class="p">):</span>
	<span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">_out</span><span class="p">,</span> <span class="n">_in</span><span class="p">)).</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
	<span class="n">bias</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_out</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">from_numpy</span><span class="p">(</span><span class="n">weight</span><span class="p">),</span> <span class="n">torch</span><span class="p">.</span><span class="nf">from_numpy</span><span class="p">(</span><span class="n">bias</span><span class="p">)</span>

<span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">seed</span><span class="p">(</span><span class="mh">0x544350</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span>
	<span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">450</span><span class="p">),</span>
	<span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">450</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span>
	<span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">layer_shapes</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">450</span><span class="p">),</span> <span class="p">(</span><span class="mi">450</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span> <span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">17</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="n">output_dim</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">layer_shapes</span><span class="p">):</span>
	<span class="n">weight</span><span class="p">,</span> <span class="n">bias</span> <span class="o">=</span> <span class="nf">tf</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="n">output_dim</span><span class="p">)</span>
	<span class="n">model</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">weight</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">weight</span>
	<span class="n">model</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bias</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">bias</span>
 
<span class="nf">print</span><span class="p">([</span><span class="n">i</span><span class="p">.</span><span class="nf">detach</span><span class="p">().</span><span class="nf">numpy</span><span class="p">().</span><span class="nf">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">model</span><span class="p">(</span><span class="nf">floatify</span><span class="p">(</span><span class="n">flag</span><span class="p">))[</span><span class="mi">0</span><span class="p">]])</span>
<span class="c1"># Output:
# [38883.9140625, 18747.87890625, -15371.05078125, 12231.2080078125, -56379.48046875, -33719.13671875, 9454.150390625, 9346.9814453125, 1701.4693603515625, -6380.3759765625, 12019.501953125, -4850.94140625, 14421.296875, 44332.0390625, -11196.283203125, -19712.0859375, -36390.265625]
</span></code></pre></div></div> <h2 id="solution">Solution</h2> <h3 id="problem-setup">Problem Setup</h3> <p>In this scenario, the model has been trained to map a 24-character input (representing the flag) to a 17-dimensional output. The challenge is to reverse the process: given the output, recover the original input (the flag).</p> <p>The flag format follows a known structure:</p> <ul> <li>The first six characters are <code class="language-plaintext highlighter-rouge">"TCP1P{"</code>.</li> <li>The last character is <code class="language-plaintext highlighter-rouge">"}"</code>.</li> <li>The remaining 17 characters need to be inferred.</li> </ul> <h3 id="step-1-target-output-setup">Step 1: Target Output Setup</h3> <p>First, we define the target output, which is the known output from the model for a specific input.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="mf">38883.9140625</span><span class="p">,</span> <span class="mf">18747.87890625</span><span class="p">,</span> <span class="o">-</span><span class="mf">15371.05078125</span><span class="p">,</span> <span class="mf">12231.2080078125</span><span class="p">,</span> <span class="o">-</span><span class="mf">56379.48046875</span><span class="p">,</span>
          <span class="o">-</span><span class="mf">33719.13671875</span><span class="p">,</span> <span class="mf">9454.150390625</span><span class="p">,</span> <span class="mf">9346.9814453125</span><span class="p">,</span> <span class="mf">1701.4693603515625</span><span class="p">,</span> <span class="o">-</span><span class="mf">6380.3759765625</span><span class="p">,</span>
          <span class="mf">12019.501953125</span><span class="p">,</span> <span class="o">-</span><span class="mf">4850.94140625</span><span class="p">,</span> <span class="mf">14421.296875</span><span class="p">,</span> <span class="mf">44332.0390625</span><span class="p">,</span> <span class="o">-</span><span class="mf">11196.283203125</span><span class="p">,</span>
          <span class="o">-</span><span class="mf">19712.0859375</span><span class="p">,</span> <span class="o">-</span><span class="mf">36390.265625</span><span class="p">]</span>

<span class="c1"># Convert the output into a format PyTorch can use
</span><span class="n">target_output</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="n">output</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">output</code> list represents the expected result from the neural network. We convert it into a PyTorch tensor so it can be used as a target for optimisation.</p> <h3 id="step-2-constructing-an-initial-flag-candidate">Step 2: Constructing an Initial Flag Candidate</h3> <p>We know the first six and last characters of the flag, but the 17 characters in the middle are unknown. We start by randomly initialising these 17 characters.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Known characters of the flag
</span><span class="n">first_six_chars</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TCP1P{</span><span class="sh">"</span>  <span class="c1"># Known prefix
</span><span class="n">last_char</span> <span class="o">=</span> <span class="sh">"</span><span class="s">}</span><span class="sh">"</span>              <span class="c1"># Known suffix
</span>
<span class="c1"># Construct the initial flag candidate
</span><span class="n">known_chars</span> <span class="o">=</span> <span class="p">[</span><span class="nf">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">first_six_chars</span><span class="p">]</span>
<span class="n">middle_length</span> <span class="o">=</span> <span class="mi">17</span>  <span class="c1"># Total length is 24; 6 + middle + 1 = 24, so 17 middle characters
</span><span class="n">middle_chars</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">middle_length</span><span class="p">)).</span><span class="nf">tolist</span><span class="p">()</span>  <span class="c1"># Random initial middle characters
</span><span class="n">known_chars</span> <span class="o">+=</span> <span class="n">middle_chars</span> <span class="o">+</span> <span class="p">[</span><span class="nf">ord</span><span class="p">(</span><span class="n">last_char</span><span class="p">)]</span>

<span class="c1"># Create an input tensor with the known characters
</span><span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="n">known_chars</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div> <p>Here, we initialise the middle part of the flag randomly and combine it with the known prefix and suffix. The complete flag candidate is stored in a PyTorch tensor, and gradients are enabled for optimisation.</p> <h3 id="step-3-setting-up-the-optimiser">Step 3: Setting Up the Optimiser</h3> <p>We use the Adam optimizer to iteratively adjust the input tensor to minimize the difference between the model’s output for the current flag candidate and the target output.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Optimiser setup
</span><span class="n">optimiser</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">.</span><span class="nc">Adam</span><span class="p">([</span><span class="n">input_tensor</span><span class="p">],</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># Learning rate
</span></code></pre></div></div> <p>The learning rate controls the step size during optimisation. Setting it to 0.1 allows for gradual adjustments.</p> <h3 id="step-4-gradient-descent-optimisation">Step 4: Gradient Descent Optimisation</h3> <p>The goal of this step is to iteratively refine the input tensor so that the model’s output matches the target output as closely as possible. This is done by minimising the mean squared error (MSE) loss.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Number of iterations for optimisation
</span><span class="n">num_iterations</span> <span class="o">=</span> <span class="mi">50000</span>

<span class="c1"># Gradient-based optimisation loop
</span><span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_iterations</span><span class="p">):</span>
    <span class="n">optimiser</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>  <span class="c1"># Zero out the gradients
</span>
    <span class="c1"># Forward pass through the model
</span>    <span class="n">output</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span>

    <span class="c1"># Compute the loss
</span>    <span class="n">loss</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">functional</span><span class="p">.</span><span class="nf">mse_loss</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target_output</span><span class="p">)</span>
    
    <span class="c1"># If loss is zero break from the training loop
</span>    <span class="k">if</span> <span class="n">loss</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">break</span>

    <span class="c1"># Backward pass (compute gradients)
</span>    <span class="n">loss</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>

    <span class="c1"># Gradient update step
</span>    <span class="n">optimiser</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>

    <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="nf">no_grad</span><span class="p">():</span>
        <span class="c1"># Ensure the first six and last character are fixed
</span>        <span class="n">input_tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="nf">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">first_six_chars</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">input_tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nf">ord</span><span class="p">(</span><span class="n">last_char</span><span class="p">)</span>

    <span class="c1"># Print progress
</span>    <span class="k">if</span> <span class="n">iteration</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Iteration </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s">, Loss: </span><span class="si">{</span><span class="n">loss</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <ul> <li>The optimiser updates the input tensor based on the gradients of the loss function with respect to the input.</li> <li>To maintain the known structure of the flag, the first six and last characters are kept fixed after each update.</li> <li>The process continues for a maximum of 50,000 iterations or until the loss reaches zero.</li> </ul> <h3 id="step-5-converting-the-optimised-tensor-back-to-a-flag">Step 5: Converting the Optimised Tensor Back to a Flag</h3> <p>Finally, we convert the adjusted input tensor into a string that represents the optimised flag candidate.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Convert the optimised input tensor back to a flag candidate
</span><span class="n">optimised_flag</span> <span class="o">=</span> <span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">chr</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="nf">round</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">input_tensor</span><span class="p">.</span><span class="nf">detach</span><span class="p">().</span><span class="nf">numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Optimised Flag Candidate: </span><span class="si">{</span><span class="n">optimised_flag</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>After the optimisation loop, we round the values in the tensor to the nearest integers and convert them to characters, forming the recovered flag.</p> <h3 id="summary">Summary</h3> <p>This code attempts to reverse the neural network’s behaviour by finding an input (flag) that produces a given output. It leverages gradient descent to minimise the error between the model’s output for the current input and the target output, adjusting the input iteratively while keeping certain known characters fixed. The process is complete when the loss reaches zero, indicating successful flag recovery.</p> <h3 id="output">Output</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Iteration 0, Loss: 132506472.0
Iteration 100, Loss: 84305080.0
Iteration 200, Loss: 51630704.0
Iteration 300, Loss: 30629590.0
...
Iteration 49900, Loss: 0.006987122818827629
Optimised Flag Candidate: TCP1P{1ts_tr3ndy_NN_n0w}
</code></pre></div></div> <h2 id="solution-code">Solution Code</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">torch</span><span class="p">,</span> <span class="n">random</span>
<span class="kn">import</span> <span class="n">torch.nn</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">flag</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TCP1P{}</span><span class="sh">"</span>

<span class="k">def</span> <span class="nf">floatify</span><span class="p">(</span><span class="n">ip</span><span class="p">):</span>
	<span class="n">flag</span> <span class="o">=</span> <span class="p">[</span><span class="nf">float</span><span class="p">(</span><span class="nf">ord</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">]</span>
	<span class="n">normalized</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="n">flag</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    
	<span class="k">return</span> <span class="n">normalized</span>
<span class="k">def</span> <span class="nf">tf</span><span class="p">(</span><span class="n">_in</span><span class="p">,</span><span class="n">_out</span><span class="p">):</span>
	<span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">_out</span><span class="p">,</span> <span class="n">_in</span><span class="p">)).</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
	<span class="n">bias</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_out</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">from_numpy</span><span class="p">(</span><span class="n">weight</span><span class="p">),</span> <span class="n">torch</span><span class="p">.</span><span class="nf">from_numpy</span><span class="p">(</span><span class="n">bias</span><span class="p">)</span>

<span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">seed</span><span class="p">(</span><span class="mh">0x544350</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span>
	<span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">450</span><span class="p">),</span>
	<span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">450</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span>
	<span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
<span class="p">)</span>


<span class="n">layer_shapes</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">450</span><span class="p">),</span> <span class="p">(</span><span class="mi">450</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span> <span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">17</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="n">output_dim</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">layer_shapes</span><span class="p">):</span>
	<span class="n">weight</span><span class="p">,</span> <span class="n">bias</span> <span class="o">=</span> <span class="nf">tf</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="n">output_dim</span><span class="p">)</span>
	<span class="n">model</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">weight</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">weight</span>
	<span class="n">model</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bias</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">bias</span>
 

<span class="c1"># Output:
# [38883.9140625, 18747.87890625, -15371.05078125, 12231.2080078125, -56379.48046875, -33719.13671875, 9454.150390625, 9346.9814453125, 1701.4693603515625, -6380.3759765625, 12019.501953125, -4850.94140625, 14421.296875, 44332.0390625, -11196.283203125, -19712.0859375, -36390.265625]
</span>
<span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="mf">38883.9140625</span><span class="p">,</span> <span class="mf">18747.87890625</span><span class="p">,</span> <span class="o">-</span><span class="mf">15371.05078125</span><span class="p">,</span> <span class="mf">12231.2080078125</span><span class="p">,</span> <span class="o">-</span><span class="mf">56379.48046875</span><span class="p">,</span> <span class="o">-</span><span class="mf">33719.13671875</span><span class="p">,</span> <span class="mf">9454.150390625</span><span class="p">,</span> <span class="mf">9346.9814453125</span><span class="p">,</span> <span class="mf">1701.4693603515625</span><span class="p">,</span> <span class="o">-</span><span class="mf">6380.3759765625</span><span class="p">,</span> <span class="mf">12019.501953125</span><span class="p">,</span> <span class="o">-</span><span class="mf">4850.94140625</span><span class="p">,</span> <span class="mf">14421.296875</span><span class="p">,</span> <span class="mf">44332.0390625</span><span class="p">,</span> <span class="o">-</span><span class="mf">11196.283203125</span><span class="p">,</span> <span class="o">-</span><span class="mf">19712.0859375</span><span class="p">,</span> <span class="o">-</span><span class="mf">36390.265625</span><span class="p">]</span>

<span class="c1">#convert the output into a format PyTorch can use
</span><span class="n">target_output</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="n">output</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>


<span class="c1"># Known characters of the flag
</span><span class="n">first_six_chars</span> <span class="o">=</span> <span class="sh">"</span><span class="s">TCP1P{</span><span class="sh">"</span>  <span class="c1"># Known prefix
</span><span class="n">last_char</span> <span class="o">=</span> <span class="sh">"</span><span class="s">}</span><span class="sh">"</span>              <span class="c1"># Known suffix
</span>
<span class="c1"># Construct the initial flag candidate
</span><span class="n">known_chars</span> <span class="o">=</span> <span class="p">[</span><span class="nf">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">first_six_chars</span><span class="p">]</span>
<span class="n">middle_length</span> <span class="o">=</span> <span class="mi">17</span>  <span class="c1"># Total length is 24; 6 + middle + 1 = 24, so 17 middle characters
</span><span class="n">middle_chars</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">middle_length</span><span class="p">)).</span><span class="nf">tolist</span><span class="p">()</span>  <span class="c1"># Random initial middle characters
</span><span class="n">known_chars</span> <span class="o">+=</span> <span class="n">middle_chars</span> <span class="o">+</span> <span class="p">[</span><span class="nf">ord</span><span class="p">(</span><span class="n">last_char</span><span class="p">)]</span>

<span class="c1"># Create an input tensor with the known characters
</span><span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="n">known_chars</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Target output (adjust according to your expectations)
</span>
<span class="c1"># Optimiser setup
</span><span class="n">optimiser</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">.</span><span class="nc">Adam</span><span class="p">([</span><span class="n">input_tensor</span><span class="p">],</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># Learning rate
</span>
<span class="c1"># Number of iterations for optimisation
</span><span class="n">num_iterations</span> <span class="o">=</span> <span class="mi">50000</span>

<span class="c1"># Gradient-based optimisation loop
</span><span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_iterations</span><span class="p">):</span>
    <span class="n">optimiser</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>  <span class="c1"># Zero out the gradients
</span>
    <span class="c1"># Forward pass through the model
</span>    <span class="n">output</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span>

    <span class="c1"># Compute the loss
</span>    <span class="n">loss</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">functional</span><span class="p">.</span><span class="nf">mse_loss</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target_output</span><span class="p">)</span>
    
    <span class="c1"># If loss is zero break from training loop
</span>    <span class="k">if</span> <span class="n">loss</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">break</span>

    <span class="c1"># Backward pass (compute gradients)
</span>    <span class="n">loss</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>

    <span class="c1"># Gradient update step
</span>    <span class="n">optimiser</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>

    <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="nf">no_grad</span><span class="p">():</span>

        <span class="c1"># Ensure the first six and last character are fixed
</span>        <span class="n">input_tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="nf">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">first_six_chars</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">input_tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nf">ord</span><span class="p">(</span><span class="n">last_char</span><span class="p">)</span>

    <span class="c1">#print progress
</span>    <span class="k">if</span> <span class="n">iteration</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Iteration </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s">, Loss: </span><span class="si">{</span><span class="n">loss</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    

<span class="c1"># Convert the optimised input tensor back to a flag candidate
</span><span class="n">optimised_flag</span> <span class="o">=</span> <span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">chr</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="nf">round</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">input_tensor</span><span class="p">.</span><span class="nf">detach</span><span class="p">().</span><span class="nf">numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Optimised Flag Candidate: </span><span class="si">{</span><span class="n">optimised_flag</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="write-ups"/><category term="reverse"/><summary type="html"><![CDATA[Write up from the TCP1P 2024 CTF competition]]></summary></entry></feed>